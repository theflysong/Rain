//Generated By Copilot

#pragma once

#include "parser/ast.h"
#include "lexer/lexer.h"
#include <ostream>
#include <fstream>
#include <string>
#include <type_traits>
#include <tuple>
#include <variant>
#include <vector>
#include <sstream>
#include <typeinfo>
#if defined(__GNUG__)
#include <cxxabi.h>
#include <cstdlib>
#endif

namespace rain {

// Header-only DOT generator for the AST nodes defined in parser/ast.h.
// Usage:
//   #include "parser/ast_dot.h"
//   rain::generate_ast_dot_to_file("ast.dot", root_ptr);

namespace detail {

inline std::string escape_label(const std::string &s) {
    std::string out;
    out.reserve(s.size() + 10);
    for (char c : s) {
        switch (c) {
            case '"': out += "\\\""; break;
            case '\n': out += "\n"; break;
            case '\r': out += "\\r"; break;
            case '\t': out += "\\t"; break;
            case '<': out += "\\<"; break;
            case '>': out += "\\>"; break;
            case '|': out += "\\|"; break;
            case '{': out += "\\{"; break;
            case '}': out += "\\}"; break;
            case '\\': out += "\\\\"; break;
            default: out += c; break;
        }
    }
    return out;
}

// Traits to detect member functions
template<typename T, typename = void>
struct has_children_method : std::false_type {};
template<typename T>
struct has_children_method<T, std::void_t<decltype(std::declval<const T&>().children())>> : std::true_type {};

template<typename T, typename = void>
struct has_child_method : std::false_type {};
template<typename T>
struct has_child_method<T, std::void_t<decltype(std::declval<const T&>().child()), decltype(std::declval<const T&>().index())>> : std::true_type {};

template<typename T, typename = void>
struct has_token_method : std::false_type {};
template<typename T>
struct has_token_method<T, std::void_t<decltype(std::declval<const T&>().token())>> : std::true_type {};

// Helpers to detect tuple/vector types
template<typename T>
struct is_tuple : std::false_type {};
template<typename... Ts>
struct is_tuple<std::tuple<Ts...>> : std::true_type {};

template<typename T>
struct is_vector : std::false_type {};
template<typename U>
struct is_vector<std::vector<U>> : std::true_type {};

// Dot generator class
class DotGen {
public:
    DotGen(std::ostream &out) : out(out), next_id(0) {
        out << "digraph AST {\n";
        out << "  node [shape=box, fontname=\"Consolas\"];\n";
    }

    ~DotGen() {
        out << "}\n";
    }

    template<typename Node>
    int visit(Node* node) {
        if (node == nullptr)
            return -1;

        // Dispatch based on available API on Node
        if constexpr (has_token_method<Node>::value) {
            return visit_terminal(node);
        } else if constexpr (has_child_method<Node>::value) {
            return visit_options(node);
        } else if constexpr (has_children_method<Node>::value) {
            // children() can be tuple (ConnectionNode) or vector (ClosureNode)
            using ChildrenT = decltype(node->children());
            using PlainChildrenT = std::remove_cvref_t<ChildrenT>;
            if constexpr (is_tuple<PlainChildrenT>::value) {
                return visit_tuple_node(node);
            } else if constexpr (is_vector<PlainChildrenT>::value) {
                return visit_vector_node(node);
            } else {
                // unknown children container -> emit readable type name
                return emit_type<Node>();
            }
        } else {
            return emit_type<Node>();
        }
    }

private:
    std::ostream &out;
    int next_id;

    int emit_node(const std::string &label) {
        int id = next_id++;
        out << "  node" << id << " [label=\"" << escape_label(label) << "\"];\n";
        return id;
    }

    int emit_leaf(const std::string &label) {
        return emit_node(label);
    }

    template<typename T>
    int emit_type() {
        return emit_node(type_name<T>());
    }

    // Try to produce a readable type name. On GNU toolchains use __cxa_demangle.
    template<typename T>
    static std::string type_name() {
#if defined(__GNUG__)
        int status = 0;
        const char *name = typeid(T).name();
        char *dem = abi::__cxa_demangle(name, nullptr, nullptr, &status);
        std::string ret = (status == 0 && dem != nullptr) ? dem : name;
        free(dem);
        return ret;
#else
        return typeid(T).name();
#endif
    }

    template<typename T>
    int visit_terminal(T* node) {
        const Token *tok = node->token();
        std::string lbl = std::string("Terminal") + "\n" + (tok ? tok->content : "<null>");
        int id = emit_node(lbl);
        return id;
    }

    template<typename T>
    int visit_options(T* node) {
        std::string lbl = std::string("Options") + "\nindex=" + std::to_string(node->index());
        int id = emit_node(lbl);

        const auto &v = node->child();
        std::visit([&](auto ptr){
            using ChildT = std::decay_t<decltype(ptr)>;
            if (ptr != nullptr) {
                int cid = visit(ptr);
                if (cid >= 0) {
                    out << "  node" << id << " -> node" << cid << "\n";
                }
            }
        }, v);

        return id;
    }

    template<typename T>
    int visit_vector_node(T* node) {
        // ClosureNode: children() -> vector<T*>
        int id = emit_node("Closure");
        const auto &vec = node->children();
        for (const auto &child : vec) {
            if (child) {
                int cid = visit(child);
                if (cid >= 0) out << "  node" << id << " -> node" << cid << "\n";
            }
        }
        return id;
    }

    template<typename T>
    int visit_tuple_node(T* node) {
        // ConnectionNode: children() -> tuple<...>
        // Use concrete type name for better label if tuple parse fails to detect
        int id = emit_node("Connection");
        const auto &tpl = node->children();
        visit_tuple_elements(id, tpl, std::make_index_sequence<std::tuple_size_v<std::remove_cv_t<std::remove_reference_t<decltype(tpl)>>>>{});
        return id;
    }

    template<typename Tuple, size_t... Is>
    void visit_tuple_elements(int parent_id, const Tuple &tpl, std::index_sequence<Is...>) {
        // Expand the parameter pack to visit each child in tuple
        (visit_tuple_element< std::remove_pointer_t<std::tuple_element_t<Is, Tuple>> >(parent_id, std::get<Is>(tpl)), ...);
    }

    // Handle a single tuple element. ElemT is the pointed-to node type (e.g., PrimaryExprNode, ClosureNode<...>, OptionsNode<...>)
    template<typename ElemT>
    void visit_tuple_element(int parent_id, ElemT* childptr) {
        if (! childptr) return;

        // If ElemT has children() and that children() is a vector -> it's a ClosureNode specialization
        if constexpr (has_children_method<ElemT>::value) {
            using ChildrenT = decltype(std::declval<const ElemT&>().children());
            using PlainChildrenT = std::remove_cvref_t<ChildrenT>;
            if constexpr (is_vector<PlainChildrenT>::value) {
                // ClosureNode: link parent directly to each inner child's node
                const auto &vec = childptr->children();
                for (const auto &inner : vec) {
                    if (inner) {
                        int cid = visit(inner);
                        if (cid >= 0) out << "  node" << parent_id << " -> node" << cid << "\n";
                    }
                }
                return;
            }
        }

        // If ElemT has child()/index() (OptionsNode), link parent directly to the chosen option
        if constexpr (has_child_method<ElemT>::value) {
            const auto &v = childptr->child();
            std::visit([&](auto ptr){
                if (ptr) {
                    int cid = visit(ptr);
                    if (cid >= 0) out << "  node" << parent_id << " -> node" << cid << "\n";
                }
            }, v);
            return;
        }

        // Default: regular node, visit and link
        int cid = visit(childptr);
        if (cid >= 0) out << "  node" << parent_id << " -> node" << cid << "\n";
    }
};

} // namespace detail

// Public helper to write an AST rooted at `root` (any node type) into `path`.
template<typename Root>
inline void generate_ast_dot_to_file(const std::string &path, Root *root) {
    std::ofstream ofs(path);
    if (! ofs) return;
    detail::DotGen gen(ofs);
    gen.visit(root);
}

} // namespace rain
